local ls = require("luasnip")
-- some shorthands...
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local l = require("luasnip.extras").lambda
local r = require("luasnip.extras").rep
local p = require("luasnip.extras").partial
local m = require("luasnip.extras").match
local n = require("luasnip.extras").nonempty
local dl = require("luasnip.extras").dynamic_lambda
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local types = require("luasnip.util.types")
local conds = require("luasnip.extras.expand_conditions")

local util = require("luasnip.util.util")
local node_util = require("luasnip.nodes.util")

local utils = require("snippets.all.utils")

-- default text generation
local function set_defaults()
	local function reduce(numer, denom)
		for gcd = math.max(numer, denom), 2, -1 do
			if numer % gcd == 0 and denom % gcd == 0 then
				numer = math.floor(numer / gcd)
				denom = math.floor(denom / gcd)
			end
		end
		return numer, denom
	end

	local defaults = { pow = {}, root = {}, pi = {}, trig = {} }

	-- pow and root
	table.insert(defaults.trig, { "<>", "" })
	for j = 2, 9 do
		table.insert(defaults.pow, { "^{<>}", tostring(j) })
		table.insert(defaults.trig, { "^{<>}", tostring(j) })
		table.insert(defaults.root, { "<>", j ~= 2 and tostring(j) or "" })
	end
	table.insert(defaults.trig, { "^{<>}", "-1" })
	for j = -9, -1 do
		table.insert(defaults.pow, { "^{<>}", tostring(j) })
	end
	table.insert(defaults.pow, { "^{<>}", "x" })
	-- pi
	table.insert(defaults.pi, { "<>", "\\pi" })
	local denominator = 12
	for numerator = 1, 24 do
		if numerator % 2 == 0 or numerator % 3 == 0 then
			local numer, denom = reduce(numerator, denominator)
			if denom == 1 then
				table.insert(defaults.pi, { "<>", (numer == 1 and "" or tostring(numer)) .. "\\pi" })
			else
				table.insert(
					defaults.pi,
					{ "<>", ([[\frac{%s\pi}{%d}]]):format((numer == 1 and "" or tostring(numer)), denom) }
				)
			end
		end
	end

	return defaults
end

-- dynamic list
-- https://github.com/L3MON4D3/LuaSnip/wiki/Misc#dynamicnode-with-user-input
local external_update_id = 0
-- func_indx to update the dynamicNode with different functions.
local function dynamic_node_external_update(func_indx)
	-- most of this function is about restoring the cursor to the correct
	-- position+mode, the important part are the few lines from
	-- `dynamic_node.snip:store()`.

	local function find_dynamic_node(node)
		-- the dynamicNode-key is set on snippets generated by a dynamicNode only (its'
		-- actual use is to refer to the dynamicNode that generated the snippet).
		while node and not node.dynamicNode do
			node = node.parent
		end
		return node and node.dynamicNode
	end

	-- find current node and the innermost dynamicNode it is inside.
	local current_node = ls.session.current_nodes[vim.api.nvim_get_current_buf()]
	local dynamic_node = find_dynamic_node(current_node)
	if -- exit if not in relevant snippet
		not (dynamic_node and dynamic_node.parent and dynamic_node.parent.snippet and dynamic_node.parent.snippet.rows)
	then
		return
	end
	-- to identify current node in new snippet, if it is available.
	external_update_id = external_update_id + 1
	current_node.external_update_id = external_update_id

	-- store which mode we're in to restore later.
	local insert_pre_call = vim.fn.mode() == "i"
	-- is byte-indexed! Doesn't matter here, but important to be aware of.
	local cursor_pos_pre_relative = util.pos_sub(util.get_cursor_0ind(), current_node.mark:pos_begin_raw())

	-- leave current generated snippet.
	node_util.leave_nodes_between(dynamic_node.snip, current_node)

	-- call update-function.
	local func = dynamic_node.user_args[func_indx]
	if func then
		-- the same snippet passed to the dynamicNode-function. Any output from func
		-- should be stored in it under some unused key.
		func(dynamic_node.parent.snippet)
	end

	-- last_args is used to store the last args that were used to generate the
	-- snippet. If this function is called, these will most probably not have
	-- changed, so they are set to nil, which will force an update.
	dynamic_node.last_args = nil
	dynamic_node:update()

	-- everything below here isn't strictly necessary, but it's pretty nice to have.
	-- try to find the node we marked earlier.
	local target_node = dynamic_node:find_node(function(test_node)
		return test_node.external_update_id == external_update_id
	end)

	if target_node then
		-- the node that the cursor was in when changeChoice was called exists
		-- in the active choice! Enter it and all nodes between it and this choiceNode,
		-- then set the cursor.
		node_util.enter_nodes_between(dynamic_node, target_node)

		if insert_pre_call then
			util.set_cursor_0ind(util.pos_add(target_node.mark:pos_begin_raw(), cursor_pos_pre_relative))
		else
			node_util.select_node(target_node)
		end
		-- set the new current node correctly.
		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = target_node
	else
		-- the marked node wasn't found, just jump into the new snippet noremally.
		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = dynamic_node.snip:jump_into(1)
	end
end

local M = {

	update_list = dynamic_node_external_update,

	defaults = set_defaults(),

	smart_pairs = function(args, parent, old_state, user_args)
		local nodes, LHS, RHS = unpack(user_args)
		local use_LR = function(text)
			return text:match("frac") ~= nil or text:match("[_^]") ~= nil
		end
		return sn(1, {
			d(
				1,
				function(args) -- for some reason regular f nodes caused strange behavior when attempting to delete snippet
					local result = (use_LR(args[1][1]) and "\\left" or "") .. LHS
					return sn(nil, t(result))
				end,
				{ 2 },
				{}
			),
			d(2, utils.paste, {}, { user_args = { nodes } }),
			d(3, function(args)
				local result = (use_LR(args[1][1]) and "\\right" or "") .. RHS
				return sn(nil, t(result))
			end, { 2 }, {}),
		})
	end,

	get_choices = function(args, parent, old_state, user_args)
		local choices = {}
		require("cmp").close() -- don't want cmp selection when we are making choices
		for _, v in ipairs(user_args) do
			table.insert(choices, fmta(v[1], { i(1, v[2]) }))
		end
		return sn(nil, c(1, choices))
	end,
}

return M
